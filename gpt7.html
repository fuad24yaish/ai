<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Responses API + File Search (Vector Stores)</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;max-width:900px;margin:auto;padding:20px}
  #responseArea{white-space:pre-wrap;border:1px solid #ccc;padding:10px;min-height:150px;background:#fafafa}
  input,select,button,textarea{padding:8px;margin-top:6px}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .warn{background:#fff7d6;border:1px solid #e7d070;padding:8px 10px;border-radius:6px}
  #fileList{font-size:12px;color:#555;white-space:pre-wrap}
</style>
</head>
<body>
<h1>Responses API + File Search (No Threads)</h1>
<p class="warn"><b>Warning:</b> Browser demo. Your API key is exposed. Use a backend in production.</p>

<label>API Key:</label><br>
<input type="password" id="apiKey" placeholder="sk-..." size="60"><br><br>

<label>Prompt:</label><br>
<input type="text" id="userInput" style="width:100%" placeholder="Ask about the attached files..."><br>

<div class="row">
  <label>Attach files (images/audio inline; others go to a vector store):</label>
  <input type="file" id="attachments" multiple>
</div>
<div id="fileList"></div>

<div class="row" style="margin-top:10px">
  <label>Model:</label>
  <select id="model">
    <option value="gpt-4o-mini" selected>gpt-4o-mini</option>
    <option value="gpt-4.1-mini">gpt-4.1-mini</option>
    <option value="gpt-4.1">gpt-4.1</option>
  </select>
  <label><input type="checkbox" id="streamToggle" checked> Stream</label>
</div>

<br>
<button id="runBtn">Run</button>

<h2>Response</h2>
<div id="responseArea"></div>

<script>
const $ = (id) => document.getElementById(id);
$('attachments').addEventListener('change', () => {
  const files = $('attachments').files;
  $('fileList').textContent = [...files].map(f =>
    `• ${f.name} (${f.type || 'unknown'}, ${(f.size/1024).toFixed(1)} KB)`
  ).join('\n');
});
$('runBtn').addEventListener('click', run);

let VECTOR_STORE_ID = null;  // created lazily if needed

async function run(){
  const apiKey = $('apiKey').value.trim();
  const responseArea = $('responseArea');
  const model = $('model').value;
  const stream = $('streamToggle').checked;
  const userText = $('userInput').value.trim();
  const files = $('attachments').files;

  responseArea.textContent = '';
  if(!apiKey){ responseArea.textContent = 'Enter API key.'; return; }
  if(!userText && !files.length){ responseArea.textContent='Enter a prompt or attach files.'; return; }

  try {
    // Build input parts + (optionally) prepare vector store
    const { parts, vectorStoreId } = await prepareInputAndVectorStore(apiKey, userText, files, responseArea);

    // Compose the Responses body per File Search guide
    const body = {
      model,
      input: [{ role: 'user', content: parts }],
      // enable file_search tool when we have a vector store
      tools: vectorStoreId ? [{ type: 'file_search' }] : undefined,
      tool_resources: vectorStoreId ? { file_search: { vector_store_ids: [vectorStoreId] } } : undefined,
      stream: !!stream
    };

    if (stream) {
      await streamResponse(apiKey, body, responseArea);
    } else {
      await jsonResponse(apiKey, body, responseArea);
    }
  } catch (e){
    responseArea.textContent = 'Error: ' + (e?.message || e);
    console.error(e);
  }
}

/** Build input parts:
 *  - input_text for prompt
 *  - input_image (data URL)
 *  - input_audio (base64 + format)
 *  - other docs → upload → add to vector store → return VS id
 */
async function prepareInputAndVectorStore(apiKey, userText, files, el){
  const parts = [];
  if (userText) parts.push({ type: 'input_text', text: userText });

  const nonInline = [];
  for (const f of files){
    const mime = (f.type || '').toLowerCase();
    const name = (f.name || '').toLowerCase();
    if (mime.startsWith('image/')) {
      parts.push({ type: 'input_image', image_url: await readAsDataURL(f) });
    } else if (mime.startsWith('audio/')) {
      const { base64, fmt } = await toBase64Fmt(f);
      parts.push({ type: 'input_audio', audio: { data: base64, format: fmt } });
    } else if (mime === 'text/plain' || name.endsWith('.txt')) {
      parts.push({ type: 'input_text', text: `File ${f.name}:\n` + await readAsText(f) });
    } else {
      nonInline.push(f); // PDF/DOC/DOCX/CSV/…
    }
  }

  if (!nonInline.length) return { parts, vectorStoreId: null };

  const vsId = await ensureVectorStore(apiKey, el);
  const fileIds = [];
  for (const f of nonInline) fileIds.push(await uploadFile(apiKey, f, el));
  await addFilesToVectorStore(apiKey, vsId, fileIds, el);
  return { parts, vectorStoreId: vsId };
}

// ---------- Vector Stores ----------
async function ensureVectorStore(apiKey, el){
  if (VECTOR_STORE_ID) return VECTOR_STORE_ID;
  append(el, 'Creating vector store …');
  const r = await fetch('https://api.openai.com/v1/vector_stores', {
    method:'POST',
    headers:{ 'Authorization':`Bearer ${apiKey}`, 'Content-Type':'application/json' },
    body: JSON.stringify({ name: 'Browser Demo Store' })
  });
  const j = await r.json();
  if (!r.ok) throw new Error(j?.error?.message || 'Failed to create vector store');
  VECTOR_STORE_ID = j.id; // vs_...
  append(el, `Vector store: ${VECTOR_STORE_ID}`);
  return VECTOR_STORE_ID;
}

async function uploadFile(apiKey, file, el){
  append(el, `Uploading ${file.name} …`);
  const form = new FormData();
  form.append('file', file, file.name);
  form.append('purpose', 'user_data');   // general purpose for RAG
  const r = await fetch('https://api.openai.com/v1/files', {
    method:'POST',
    headers:{ 'Authorization':`Bearer ${apiKey}` },
    body: form
  });
  const j = await r.json();
  if (!r.ok) throw new Error(j?.error?.message || `Upload failed: ${file.name}`);
  append(el, `Uploaded ✓ → ${j.id}`);
  return j.id;
}

async function addFilesToVectorStore(apiKey, vsId, fileIds, el){
  if (!fileIds.length) return;
  append(el, `Indexing ${fileIds.length} file(s) into ${vsId} …`);
  const r = await fetch(`https://api.openai.com/v1/vector_stores/${vsId}/file_batches`, {
    method:'POST',
    headers:{ 'Authorization':`Bearer ${apiKey}`, 'Content-Type':'application/json' },
    body: JSON.stringify({ file_ids: fileIds })
  });
  const j = await r.json();
  if (!r.ok) throw new Error(j?.error?.message || 'Failed to add files to vector store');
  append(el, `Indexing started (batch ${j.id || 'ok'}).`);
}

// ---------- Readers ----------
function readAsDataURL(file){ return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=()=>rej(r.error); r.readAsDataURL(file); }); }
function readAsText(file){ return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(String(r.result||'')); r.onerror=()=>rej(r.error); r.readAsText(file); }); }
async function toBase64Fmt(file){
  const buf = await file.arrayBuffer();
  const base64 = btoa(String.fromCharCode(...new Uint8Array(buf)));
  const t = (file.type || '').toLowerCase();
  let fmt = 'mp3';
  if (t.includes('wav')) fmt='wav';
  else if (t.includes('mpeg')||t.includes('mp3')) fmt='mp3';
  else if (t.includes('m4a') || file.name.toLowerCase().endsWith('.m4a')) fmt='m4a';
  else if (t.includes('ogg')) fmt='ogg';
  else if (t.includes('webm')) fmt='webm';
  return { base64, fmt };
}

// ---------- Responses calls ----------
async function streamResponse(apiKey, body, responseArea){
  const r = await fetch('https://api.openai.com/v1/responses', {
    method:'POST',
    headers:{ 'Authorization':`Bearer ${apiKey}`, 'Content-Type':'application/json' },
    body: JSON.stringify(body)
  });
  const okJson = await safeJson(r);
  if(!r.ok) throw new Error(okJson?.error?.message || `${r.status} ${r.statusText}`);

  const reader = r.body.pipeThrough(new TextDecoderStream()).getReader();
  let buffer = '';
  while(true){
    const { value, done } = await reader.read();
    if(done) break;
    buffer += value;

    const frames = buffer.split('\n\n');
    buffer = frames.pop();

    for(const frame of frames){
      let event = null, data = '';
      for(const line of frame.split('\n')){
        if(line.startsWith('event:')) event = line.slice(6).trim();
        else if(line.startsWith('data:')) data += (data?'\n':'') + line.slice(5).trim();
      }
      if(!data) continue;

      try{
        const payload = JSON.parse(data);
        if (event === 'response.output_text.delta' && payload?.delta){
          responseArea.textContent += payload.delta;
        }
        if (event === 'response.error'){
          throw new Error(payload?.error?.message || 'Streaming error');
        }
      } catch { /* ignore keep-alives */ }
    }
  }
}

async function jsonResponse(apiKey, body, responseArea){
  const r = await fetch('https://api.openai.com/v1/responses', {
    method:'POST',
    headers:{ 'Authorization':`Bearer ${apiKey}`, 'Content-Type':'application/json' },
    body: JSON.stringify(body)
  });
  const j = await r.json();
  if(!r.ok) throw new Error(j?.error?.message || r.statusText);

  let text = '';
  if (typeof j.output_text === 'string') text = j.output_text;
  else if (Array.isArray(j.output)){
    for (const item of j.output){
      if (Array.isArray(item?.content)){
        for (const c of item.content){
          if (c?.type === 'output_text' && typeof c?.text === 'string') text += c.text;
        }
      }
    }
  }
  responseArea.textContent = text || '[No text output]';
}

async function safeJson(r){ try{ return await r.clone().json(); } catch { return null; } }

function append(el, msg){ el.textContent += (el.textContent ? '\n' : '') + msg; }
</script>
</body>
</html>
