<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>OpenAI Responses API — Files & Attachments (Insecure Demo)</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;max-width:900px;margin:auto;padding:20px}
  #responseArea{white-space:pre-wrap;border:1px solid #ccc;padding:10px;min-height:150px;background:#fafafa}
  input,select,button,textarea{padding:8px;margin-top:6px}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .warn{background:#fff7d6;border:1px solid #e7d070;padding:8px 10px;border-radius:6px}
  #fileList{font-size:12px;color:#555;white-space:pre-wrap}
  .info{background:#e3f2fd;border:1px solid #90caf9;padding:8px 10px;border-radius:6px;margin-top:8px;font-size:13px}
</style>
</head>
<body>
<h1>Responses API — Files & Attachments</h1>
<p class="warn"><b>Warning:</b> This page sends your API key from the browser. Use only for quick local tests.</p>

<label>API Key:</label><br>
<input type="password" id="apiKey" placeholder="sk-..." size="60"><br><br>

<label>Prompt:</label><br>
<input type="text" id="userInput" style="width:100%" placeholder="Ask about the attached files or type your question..."><br>

<div class="row">
  <label>Local attachments (images / audio / .txt / small PDF/DOCX):</label>
  <input type="file" id="attachments" multiple accept="image/*,audio/*,.txt,.pdf,.docx">
</div>
<div class="info">
  <b>Small files (≤5MB):</b> PDF and DOCX files will be uploaded inline automatically.<br>
  <b>Large files (>5MB):</b> Upload via <code>POST /v1/files</code> first, then paste file IDs below.
</div>
<div id="fileList"></div>

<div class="row" style="margin-top:10px">
  <div style="flex:1;min-width:280px">
    <label>Remote file IDs (for large PDF, DOCX, etc.) — comma or newline separated</label><br>
    <textarea id="fileIds" rows="3" style="width:100%" placeholder="file_abc123, file_def456"></textarea>
    <div style="font-size:12px;color:#666;margin-top:4px">
      Upload large documents via <code>POST /v1/files</code>, then paste their <code>file_id</code> values here.
    </div>
  </div>
</div>

<div class="row" style="margin-top:10px">
  <label>Model:</label>
  <select id="model">
    <option value="gpt-4o-mini" selected>gpt-4o-mini</option>
    <option value="gpt-4.1-mini">gpt-4.1-mini</option>
    <option value="gpt-4.1">gpt-4.1</option>
    <option value="gpt-5">gpt-5</option>
  </select>
  <label><input type="checkbox" id="streamToggle" checked> Stream</label>
</div>

<br>
<button id="runBtn">Run</button>

<h2>Response</h2>
<div id="responseArea"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
<script>
const $ = (id) => document.getElementById(id);
const MAX_INLINE_SIZE = 5 * 1024 * 1024; // 5MB

pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

$('attachments').addEventListener('change', () => {
  const files = $('attachments').files;
  $('fileList').textContent = [...files].map(f => {
    const size = (f.size/1024).toFixed(1);
    const sizeLabel = f.size > MAX_INLINE_SIZE ? `${size} KB - TOO LARGE, use file ID` : `${size} KB`;
    return `• ${f.name} (${f.type || 'unknown'}, ${sizeLabel})`;
  }).join('\n');
});
$('runBtn').addEventListener('click', run);

async function run(){
  const apiKey = $('apiKey').value.trim();
  const responseArea = $('responseArea');
  const model = $('model').value;
  const stream = $('streamToggle').checked;

  const userText = $('userInput').value;
  const localFiles = $('attachments').files;
  const fileIds = parseFileIds($('fileIds').value);

  responseArea.textContent = '';
  if(!apiKey){ responseArea.textContent='Enter API key.'; return; }
  if(!userText && !localFiles.length && !fileIds.length){
    responseArea.textContent='Enter a prompt or provide files.';
    return;
  }

  try {
    responseArea.textContent = 'Processing files...';
    
    // Build user content parts (text + inline files)
    const content = await buildContent(userText, localFiles);

    // Build attachments for uploaded files (large PDF/DOCX via file IDs)
    const attachments = fileIds.map(id => ({
      file_id: id,
      tools: [{ type: 'file_search' }]
    }));

    const body = {
      model,
      input: [{ role: 'user', content }],
      tools: attachments.length ? [{ type: 'file_search' }] : undefined,
      attachments: attachments.length ? attachments : undefined,
      stream: stream || false
    };

    responseArea.textContent = '';
    
    if (stream) {
      await streamResponse(apiKey, body, responseArea);
    } else {
      await jsonResponse(apiKey, body, responseArea);
    }
  } catch (e){
    responseArea.textContent = 'Error: ' + (e?.message || e);
    console.error(e);
  }
}

function parseFileIds(s){
  if(!s) return [];
  return s.split(/[\s,]+/).map(x=>x.trim()).filter(Boolean);
}

async function buildContent(userText, files){
  const parts = [];
  if (userText) parts.push({ type: 'input_text', text: userText });

  for (const f of files){
    if (f.size > MAX_INLINE_SIZE){
      parts.push({ type: 'input_text', text: `[Note: ${f.name} is too large (${(f.size/1024/1024).toFixed(2)}MB). Upload via /v1/files API and use file ID instead.]` });
      continue;
    }

    if (f.type.startsWith('image/')){
      const dataUrl = await readAsDataURL(f);
      parts.push({ type: 'input_image', image_url: dataUrl });
    } else if (f.type.startsWith('audio/')){
      const { base64, fmt } = await toBase64Fmt(f);
      parts.push({ type: 'input_audio', audio: { data: base64, format: fmt } });
    } else if (isPdf(f)){
      const text = await extractPdfText(f);
      parts.push({ type: 'input_text', text: `File ${f.name} (PDF):\n${text}` });
    } else if (isDocx(f)){
      const text = await extractDocxText(f);
      parts.push({ type: 'input_text', text: `File ${f.name} (DOCX):\n${text}` });
    } else if (isTxt(f)){
      const txt = await readAsText(f);
      parts.push({ type: 'input_text', text: `File ${f.name}:\n${txt}` });
    } else {
      parts.push({ type: 'input_text', text: `[Unsupported file type: ${f.name}]` });
    }
  }
  return parts;
}

function isTxt(file){
  const n = (file.name || '').toLowerCase();
  return file.type === 'text/plain' || n.endsWith('.txt');
}

function isPdf(file){
  const n = (file.name || '').toLowerCase();
  return file.type === 'application/pdf' || n.endsWith('.pdf');
}

function isDocx(file){
  const n = (file.name || '').toLowerCase();
  return file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || n.endsWith('.docx');
}

async function extractPdfText(file){
  try {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    let text = '';
    
    for (let i = 1; i <= pdf.numPages; i++){
      const page = await pdf.getPage(i);
      const content = await page.getTextContent();
      const pageText = content.items.map(item => item.str).join(' ');
      text += `\n--- Page ${i} ---\n${pageText}\n`;
    }
    
    return text || '[No text extracted from PDF]';
  } catch (e){
    return `[Error extracting PDF: ${e.message}]`;
  }
}

async function extractDocxText(file){
  try {
    const arrayBuffer = await file.arrayBuffer();
    const result = await mammoth.extractRawText({ arrayBuffer });
    return result.value || '[No text extracted from DOCX]';
  } catch (e){
    return `[Error extracting DOCX: ${e.message}]`;
  }
}

function readAsDataURL(file){
  return new Promise((res, rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=()=>rej(r.error); r.readAsDataURL(file); });
}
function readAsText(file){
  return new Promise((res, rej)=>{ const r=new FileReader(); r.onload=()=>res(String(r.result||'')); r.onerror=()=>rej(r.error); r.readAsText(file); });
}
async function toBase64Fmt(file){
  const buf = await file.arrayBuffer();
  const base64 = btoa(String.fromCharCode(...new Uint8Array(buf)));
  const t = (file.type || '').toLowerCase();
  let fmt = 'mp3';
  if (t.includes('wav')) fmt='wav';
  else if (t.includes('mpeg')||t.includes('mp3')) fmt='mp3';
  else if (t.includes('m4a') || file.name.toLowerCase().endsWith('.m4a')) fmt='m4a';
  else if (t.includes('ogg')) fmt='ogg';
  else if (t.includes('webm')) fmt='webm';
  return { base64, fmt };
}

async function streamResponse(apiKey, body, responseArea){
  const r = await fetch('https://api.openai.com/v1/responses', {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  if(!r.ok){
    let msg = `${r.status} ${r.statusText}`;
    try { const j = await r.json(); if (j?.error?.message) msg = j.error.message; } catch {}
    throw new Error(msg);
  }

  const reader = r.body.pipeThrough(new TextDecoderStream()).getReader();
  let buffer = '';
  while(true){
    const { value, done } = await reader.read();
    if (done) break;
    buffer += value;

    const frames = buffer.split('\n\n');
    buffer = frames.pop();

    for (const frame of frames){
      let event = null, data = '';
      for (const line of frame.split('\n')){
        if (line.startsWith('event:')) event = line.slice(6).trim();
        else if (line.startsWith('data:')) data += (data ? '\n' : '') + line.slice(5).trim();
      }
      if (!data) continue;
      try{
        const payload = JSON.parse(data);
        if (event === 'response.output_text.delta' && payload?.delta){
          responseArea.textContent += payload.delta;
        }
        if (event === 'response.error'){
          throw new Error(payload?.error?.message || 'Streaming error');
        }
      } catch { /* ignore keep-alives */ }
    }
  }
}

async function jsonResponse(apiKey, body, responseArea){
  const r = await fetch('https://api.openai.com/v1/responses', {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  const j = await r.json();
  if (!r.ok) throw new Error(j?.error?.message || r.statusText);

  let text = '';
  if (typeof j.output_text === 'string') text = j.output_text;
  else if (Array.isArray(j.output)){
    for (const item of j.output){
      if (Array.isArray(item?.content)){
        for (const c of item.content){
          if (c?.type === 'output_text' && typeof c?.text === 'string') text += c.text;
        }
      }
    }
  }
  responseArea.textContent = text || '[No text output]';
}
</script>
</body>
</html>